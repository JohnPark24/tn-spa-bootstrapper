#
# Define the 'web' process to be run on Heroku
#
{% if cookiecutter.async.lower() == "async" %}
web: gunicorn {{ cookiecutter.project_slug }}.asgi:application -k uvicorn.workers.UvicornWorker
{% elif cookiecutter.async.lower() == "django channels" %}
web: daphne {{ cookiecutter.project_slug }}.asgi:application --port $PORT --bind 0.0.0.0 -v2
worker: python manage.py runworker -v2
{% else  %}
web: gunicorn {{ cookiecutter.project_slug }}.wsgi --log-file -
{% endif %}
# Celery
{% if cookiecutter.use_celery == "y" %}
worker: REMAP_SIGTERM=SIGQUIT celery worker --app={{ cookiecutter.project_slug }}.celery_app --loglevel=info
beat: REMAP_SIGTERM=SIGQUIT celery beat --app={{ cookiecutter.project_slug }}.celery_app --loglevel=info
{% endif %}

#
# This is not mandatory for all projects, as our process currently utilizes long-term staging
# servers, and automatically running migrations on this staging server could cause issues when
# different feature branches have different migrations. The aim is to switch to a model where our
# staging servers have a smaller lifetime, and we would not run into the above issue.
# To make this switch the following problems need to be solved.
#   1. Setting up human-readable URLS for the short-lived staging servers.
#   2. Fixtures for common test data (ex: test users, common app-specific entities)
#   3. Up-to-date build numbers shown in app (ideally auto-generated at build-and-deploy time)
#
# Uncomment the line below to enable migrations to automatically run after a Heroku push.
release: python manage.py makemigrations --noinput && python manage.py migrate --noinput


